---
layout: post
title: GC原理
date: 2017-06-30 
tag: Java基础
---

### 一.垃圾回收机制 ###

回收超出作用域或者引用计数为空的对象;从根节点开始搜索,搜索不到的对象,而且经过一次标记-清理仍然没有复活的对象的内存空间.
原理:把对象分为年青代(Young)、年老代(Tenured)、持久代(Perm)，对不同生命周期的对象使用不同的算法。(基于对对象生命周期分析)

![](http://i.imgur.com/1sNfqKC.png)![](http://i.imgur.com/S4Pia6e.png)


### 二.堆内存分配 ###

**年轻代(Young):**
　　　年轻代的生命周期很短,一般新生成的对象会存放在该区的Eden区内,如果Eden区满时,还存活的对象将被复制到survivor(两个中的一个),当　　　　一个survivor满时,此区的存活对象将被复制到另外一个survivor区,当另外一个survivor也满时,从前一个survivor区复制过来并且此时还　　　　　存活的对象,将可能被复制到年老代.

　　　年轻代又分为3个区
　　　　　　**Eden**:对象创建被分配到这个区
　　　　　　**survivor1区**:copying算法中的from space
　　　　　　**survivor2区**:copying算法中的to space

　　　年轻代的GC称为**Minor GC**. 经过数次minor gc 之后依旧存活的对象,将被移出年轻代,移到年老代.

**年老代(Tenured):**
　　　　年老代的生命周期较长,在年轻代中经过多次minor gc之后依然存活的对象,就会被复制到年老代中.
　　　　年老代中的GC成为**Full GC**

**持久代(Permanet):**
　　　　持久代比较稳定,主要用于存放classLoader信息,比如Class信息和method信息.


### 三.内存申请流程 ###
JVM会试图为相关的Java对象在年轻代的Eden区中初始化一块内存区域.
当Eden区空间足够时,内存申请结束,否则执行下一步. 执行Minor GC
JVM试图释放在Eden中所有不活跃的对象,释放后若Eden空间仍然不足以放入新对象,JVM则试图将Eden区中的活跃对象放入survivor区
当一个survivor满时,此区存活的对象将被复制到另外一个survivor区,当另外一个survivor也满时,从前一个survivor区复制过来并且此时还存活的对象将被移到年老代.
当年老代空间也不够时,JVM会在年老代进行完全的垃圾回收(Full GC).
Full GC后,若survivor区及年老代仍然无法存放从Eden区复制过来的对象时,则会导致JVM无法在Eden区为新对象申请内存空间,即出现"Out of Memory",内存溢出.

科普:
   内存溢出(out of memory):是指程序申请内存时,没有足够的内存空间供其使用,出现out of memory
   内存泄露(memory leak):是指程序在申请内存后,无法释放已申请的内存空间,导致这部分内存不可用的情况.
如何避免:
   尽早释放无用对象的引用.
   程序进行字符串处理时,尽量避免使用String,而应使用StringBuffer.
   尽量少使用静态变量 静态变量是全局的,GC不会回收
   避免集中创建对象.
   尽量运用对象池技术以提高系统性能;生命周期长的对象拥有生命周期短的对象时容易引发内存泄漏.
   不要在经常调用的方法中创建对象,尤其是循环中创建对象.可以适当的使用hashtable或者vector创建一组对象容器,然后从容器中取那些对象,而不是每次new之后再丢弃
   优化配置,见标题7

### 四.GC有两种类型 ###
1):**Minor GC:**当新对象生成,并且在Eden申请空间失败时触发.
Minor GC 是对Eden区域进行GC,清除非存活对象,并且把尚且
存活的对象移入到Survivor区.然后整理Survivor的两个区.
这种方式的GC,是对Eden区进行,不会影响到年老代.
因为大部分对象都是从Eden区开始的,同时Eden区不会分配太大,所以Eden区的GC会频繁的进行.因此在这里一般使用速度快,效率高的算法,使Eden尽快腾出空间.

2):**Full GC:**当年老代被写满,或者持久代被写满,或者显示调用System.gc(),再或者上一次GC之后Heap的各域分配策略动态变化时触发.
   Full GC 是对整个堆进行整理,包括Young,Tenured和Perm
   因为是对整个堆进行回收,因此要比Minor GC要慢很多,所以要尽可能的减少Full GC的次数
   在JVM调优的过程中,很大一部分工作都是对Full GC调节.

### 五.垃圾回收算法 ###

#### 按基本回收策略分 ####
　　**1).引用计数(Reference Counting)**
　　　　　原理是对象有一个引用,即增加一个计数,删除一个引用则减少一个计数.垃圾回收时,只用收集计数为0的对象.
　　　　　缺点是无法处理循环引用的问题.


　　**2).标记-清除(Mark-Sweep)	**
　　　　　此算法执行需要分两个阶段,第一阶段从引用根节点开始标记所有被引用的对象,第二阶段遍历整个堆
　　　　　把未标记的对象清除.
　　　　　缺点:此算法需要暂停整个应用,同时产生内存碎片.
		![](http://i.imgur.com/JjDTd6F.png)


　　**3).复制(Copying)**
　　　　　此算法把内存空间分为两个相等的区域,每次只使用其中一个区域.垃圾回收时遍历当前使用的区域,把正在使用的对象复制到另外一个区　　　　　域.
　　　　　此算法每次只处理正在使用的对象,因此复制的成本比较小,同时复制过去以后还能进行相应的内存整理,不会出现碎片问题.
　　　　　缺点:需要两倍的内存空间.一般在年轻代使用．
		![](http://i.imgur.com/ndFg86q.png)
	

　　**4).标记-整理(Mark-Compact)**
　　　　此算法结合了'标记-清除'和'复制'两个算法的优点.也是分两个阶段,第一个阶段从根节点开始标记所有被引用的对象,第二阶段遍历整个堆,　　　　清除未标记对象并把存活对象压缩到堆的其中一块,按顺序存放.
　　　　优点:避免了'标记-清除'的碎片问题,同时也避免了'复制'算法的空间问题
		![](http://i.imgur.com/G1XZDjI.png)



#### 按分区对待的方式分 ####
		
　　**1)增量收集**
　　　　　实时垃圾回收算法,即在应用进行的同时进行垃圾回收

　　**2)分代收集**
　　　　　基于对对象生命周期分析后得出的垃圾回收算法
　　　　　把对象分为年轻代,年老代,持久代,对不同生命周期的对象使用不同的算法(上述4中方式中的一种)进行回收,
　　　　　现在的垃圾回收器从J2SE1.2开始都是使用此算法.


### 六.垃圾回收器 ###
　　**1)串行收集器**
　　　　串行收集使用单线程处理所有垃圾回收工作,因为无需多线程交互,实现容易,而且效率比较高.
　　　　缺点:无法使用多处理器的优势,需要暂停整个应用
　　　　适于:小数据量100M左右;单处理器下并且对响应时间无要求的应用.
　　　　-XX:+UseSerialGC 打开
　　**2)并行收集器**
　　　　并行收集使用多线程处理垃圾回收工作,因而速度更快,效率高.而且理论上CPU数据越多,越能体现出并行收集器的优势
　　　　缺点:需要暂停整个应用,导致应用响应时间可能较长.
　　　　适于:对吞吐量有高要求的多CPU,对响应时间无要求的中大型应用.
　　　　对年轻代,-XX:+UseParallelGC打开
　　　　对年老代,-XX:+UseParallelOldGC打开
　　　　-XX:ParallelGCThreads=<N>设置并行垃圾回收的线程数.
　　**3)并发收集器**
　　　　可以保证大部分工作都并发进行,应用不停止,垃圾回收暂停时间很少.
　　　　适于:对响应时间有高要求的多CPU,对应用响应时间有较高要求的中大型应用.
　　　　-XX:+UseConMarkSweepGC打开


### 七.优化配置 ###
**堆设置**
		-Xms:初始堆大小
		-Xmx:最大堆大小
		-XX:NewSize=n:设置年轻代大小
		-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4
		-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5
		-XX:MaxPermSize=n:设置持久代大小

**收集器设置**
		-XX:+UseSerialGC:设置串行收集器
		-XX:+UseParallelGC:设置并行收集器
		-XX:+UseParalledlOldGC:设置并行年老代收集器
		-XX:+UseConcMarkSweepGC:设置并发收集器

**垃圾回收统计信息**
		-XX:+PrintGC
		-XX:+PrintGCDetails
		-XX:+PrintGCTimeStamps
		-Xloggc:filename

**并行收集器设置**
		-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。
		-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间
		-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)

**并发收集器设置**
		-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。
		-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。


