---
layout: post
title: GC原理
date: 2017-06-30 
tag: Java基础
---

### 一.垃圾回收机制 ###

回收超出作用域或者引用计数为空的对象;从根节点开始搜索,搜索不到的对象,而且经过一次标记-清理仍然没有复活的对象的内存空间.
原理:把对象分为年青代(Young)、年老代(Tenured)、持久代(Perm)，对不同生命周期的对象使用不同的算法。(基于对对象生命周期分析)

![](http://i.imgur.com/1sNfqKC.png)![](http://i.imgur.com/S4Pia6e.png)


### 二.堆内存分配 ###

**年轻代(Young):**

　　　年轻代的生命周期很短,一般新生成的对象会存放在该区的Eden区内,如果Eden区满时,还存活的对象将被复制到survivor(两个中的一个),当　　　　一个survivor满时,此区的存活对象将被复制到另外一个survivor区,当另外一个survivor也满时,从前一个survivor区复制过来并且此时还　　　　　存活的对象,将可能被复制到年老代.

　　　年轻代又分为3个区

　　　　　　**Eden**:对象创建被分配到这个区

　　　　　　**survivor1区**:copying算法中的from space

　　　　　　**survivor2区**:copying算法中的to space

　　　年轻代的GC称为**Minor GC**. 经过数次minor gc 之后依旧存活的对象,将被移出年轻代,移到年老代.

**年老代(Tenured):**

　　　　年老代的生命周期较长,在年轻代中经过多次minor gc之后依然存活的对象,就会被复制到年老代中.

　　　　年老代中的GC成为**Full GC**

**持久代(Permanet):**

　　　　持久代比较稳定,主要用于存放classLoader信息,比如Class信息和method信息.


### 三.内存申请流程 ###

1. JVM会试图为相关的Java对象在年轻代的Eden区中初始化一块内存区域.

1. 当Eden区空间足够时,内存申请结束,否则执行下一步. 执行Minor GC
 
1. JVM试图释放在Eden中所有不活跃的对象,释放后若Eden空间仍然不足以放入新对象,JVM则试图将Eden区中的活跃对象放入survivor区

1. 当一个survivor满时,此区存活的对象将被复制到另外一个survivor区,当另外一个survivor也满时,从前一个survivor区复制过来并且此时还存活的对象将被移到年老代. 

1. 当年老代空间也不够时,JVM会在年老代进行完全的垃圾回收(Full GC).
 
1. Full GC后,若survivor区及年老代仍然无法存放从Eden区复制过来的对象时,则会导致JVM无法在Eden区为新对象申请内存空间,即出现"Out of Memory",内存溢出.


科普:

     **内存溢出(out of memory)**:是指程序申请内存时,没有足够的内存空间供其使用,出现out of memory

     **内存泄露(memory leak)**:是指程序在申请内存后,无法释放已申请的内存空间,导致这部分内存不可用的情况.

如何避免:

   　　尽早释放无用对象的引用.

  　　 程序进行字符串处理时,尽量避免使用String,而应使用StringBuffer.

   　　尽量少使用静态变量 静态变量是全局的,GC不会回收

   　　避免集中创建对象.

  　　 尽量运用对象池技术以提高系统性能;生命周期长的对象拥有生命周期短的对象时容易引发内存泄漏.

   　　不要在经常调用的方法中创建对象,尤其是循环中创建对象.可以适当的使用hashtable或者vector创建一组对象容器,然后从容器中取那些对象,而不是每次new之后再丢弃

   　　优化配置,见标题7

### 四.GC有两种类型 ###

1):**Minor GC:**当新对象生成,并且在Eden申请空间失败时触发.

　　　　　Minor GC 是对Eden区域进行GC,清除非存活对象,并且把尚且
存活的对象移入到Survivor区.然后整理Survivor的两个区.
这种方式的GC,是对Eden区进行,不会影响到年老代.
因为大部分对象都是从Eden区开始的,同时Eden区不会分配太大,所以Eden区的GC会频繁的进行.因此在这里一般使用速度快,效率高的算法,使Eden尽快腾出空间.

2):**Full GC:**当年老代被写满,或者持久代被写满,或者显示调用System.gc(),再或者上一次GC之后Heap的各域分配策略动态变化时触发.

  　　　　 Full GC 是对整个堆进行整理,包括Young,Tenured和Perm
   因为是对整个堆进行回收,因此要比Minor GC要慢很多,所以要尽可能的减少Full GC的次数
   在JVM调优的过程中,很大一部分工作都是对Full GC调节.

### 五.垃圾回收算法 ###

#### 按基本回收策略分 ####
　　**1).引用计数(Reference Counting)**

　　　　　原理是对象有一个引用,即增加一个计数,删除一个引用则减少一个计数.垃圾回收时,只用收集计数为0的对象.

　　　　　缺点是无法处理循环引用的问题.


　　**2).标记-清除(Mark-Sweep)**

　　　　　此算法执行需要分两个阶段,第一阶段从引用根节点开始标记所有被引用的对象,第二阶段遍历整个堆
　　　　　把未标记的对象清除.

　　　　　缺点:此算法需要暂停整个应用,同时产生内存碎片.
		![](http://i.imgur.com/JjDTd6F.png)


　　**3).复制(Copying)**

　　　　　此算法把内存空间分为两个相等的区域,每次只使用其中一个区域.垃圾回收时遍历当前使用的区域,把正在使用的对象复制到另外一个区　　　　　域.

　　　　　此算法每次只处理正在使用的对象,因此复制的成本比较小,同时复制过去以后还能进行相应的内存整理,不会出现碎片问题.

　　　　　缺点:需要两倍的内存空间.一般在年轻代使用．
		![](http://i.imgur.com/ndFg86q.png)
	

　　**4).标记-整理(Mark-Compact)**

　　　　此算法结合了'标记-清除'和'复制'两个算法的优点.也是分两个阶段,第一个阶段从根节点开始标记所有被引用的对象,第二阶段遍历整个

　　　　堆,清除未标记对象并把存活对象压缩到堆的其中一块,按顺序存放.

　　　　优点:避免了'标记-清除'的碎片问题,同时也避免了'复制'算法的空间问题
		![](http://i.imgur.com/G1XZDjI.png)



#### 按分区对待的方式分 ####
		
　　**1)增量收集**

　　　　　实时垃圾回收算法,即在应用进行的同时进行垃圾回收

　　**2)分代收集**

　　　　　基于对对象生命周期分析后得出的垃圾回收算法

　　　　　把对象分为年轻代,年老代,持久代,对不同生命周期的对象使用不同的算法(上述4中方式中的一种)进行回收,
　　　　　现在的垃圾回收器从J2SE1.2开始都是使用此算法.


### 六.垃圾回收器 ###
　　**1)串行收集器**

　　　　串行收集使用单线程处理所有垃圾回收工作,因为无需多线程交互,实现容易,而且效率比较高.

　　　　缺点:无法使用多处理器的优势,需要暂停整个应用

　　　　适于:小数据量100M左右;单处理器下并且对响应时间无要求的应用.

　　　　-XX:+UseSerialGC 打开

　　**2)并行收集器**

　　　　并行收集使用多线程处理垃圾回收工作,因而速度更快,效率高.而且理论上CPU数据越多,越能体现出并行收集器的优势

　　　　缺点:需要暂停整个应用,导致应用响应时间可能较长.

　　　　适于:对吞吐量有高要求的多CPU,对响应时间无要求的中大型应用.

　　　　对年轻代,-XX:+UseParallelGC打开

　　　　对年老代,-XX:+UseParallelOldGC打开

　　　　-XX:ParallelGCThreads=<N>设置并行垃圾回收的线程数.

　　**3)并发收集器**

　　　　可以保证大部分工作都并发进行,应用不停止,垃圾回收暂停时间很少.

　　　　适于:对响应时间有高要求的多CPU,对应用响应时间有较高要求的中大型应用.

　　　　-XX:+UseConMarkSweepGC打开


### 七.优化配置 ###
**堆设置**

    -Xms:初始堆大小
    -Xmx:最大堆大小
    -XX:NewSize=n:设置年轻代大小
    -XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4
    -XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5
    -XX:MaxPermSize=n:设置持久代大小

**收集器设置**

    -XX:+UseSerialGC:设置串行收集器
    -XX:+UseParallelGC:设置并行收集器
    -XX:+UseParalledlOldGC:设置并行年老代收集器
    -XX:+UseConcMarkSweepGC:设置并发收集器

**垃圾回收统计信息**

    -XX:+PrintGC
    -XX:+PrintGCDetails
    -XX:+PrintGCTimeStamps
    -Xloggc:filename

**并行收集器设置**

    -XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。
    -XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间
    -XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)

**并发收集器设置**

    -XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。
    -XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。
    

### 八.调优总结 ###

**年轻代大小选择**

　　　响应时间优先的应用：尽可能设大，直到接近系统的最低响应时间限制（根据实际情况选择）。在此种情况下，年轻代收集发生的频率也是　　　最小的。同时，减少到达年老代的对象。

　　　吞吐量优先的应用：尽可能的设置大，可能到达Gbit的程度。因为对响应时间没有要求，垃圾收集可以并行进行，一般适合8CPU以上的应　　　　用。

**年老代大小选择**

　　　响应时间优先的应用：年老代使用并发收集器，所以其大小需要小心设置，一般要考虑并发会话率和会话持续时间等一些参数。如果堆设置　　　小了，可以会造成内存碎片、高回收频率以及应用暂停而使用传统的标记清除方式；如果堆大了，则需要较长的收集时间。最优化的方案，

　　　一般需要参考以下数据获得：

　　　1. 并发垃圾收集信息
　　　
　　　2. 持久代并发收集次数
 
　　　3. 传统GC信息
 
　　　4. 花在年轻代和年老代回收上的时间比例

　　　减少年轻代和年老代花费的时间，一般会提高应用的效率

**吞吐量优先的应用**

　　　　一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代。原因是，这样可以尽可能回收掉大部分短期对象，减少中期的对象，而年老代尽存放长期存活对象。较小堆引起的碎片问题

　　　　因为年老代的并发收集器使用标记、清除算法，所以不会对堆进行压缩。当收集器回收时，他会把相邻的空间进行合并，这样可以分配给较大的对象。但是，当堆空间较小时，运行一段时间以后，就会出现“碎片”，如果并发收集器找不到足够的空间，那么并发收集器将会停止，然后使用传统的标记、清除方式进行回收。如果出现“碎片”，可能需要进行如下配置：

    1. -XX:+UseCMSCompactAtFullCollection：使用并发收集器时，开启对年老代的压缩。
    2. -XX:CMSFullGCsBeforeCompaction=0：上面配置开启的情况下，这里设置多少次Full GC后，对年老代进行压缩


### 九.调优工具 ###
**VisualVM**

![](http://i.imgur.com/Yr6KOs0.png)

**如何调优**

观察内存释放情况、集合类检查、对象树

上面这些调优工具都提供了强大的功能，但是总的来说一般分为以下几类功能

**堆信息查看**

![](http://i.imgur.com/i14tBGX.jpg)

可查看堆空间大小分配（年轻代、年老代、持久代分配）

提供即时的垃圾回收功能

垃圾监控（长时间监控回收情况）

![](http://i.imgur.com/Tx6wwgK.jpg)

查看堆内类、对象信息查看：数量、类型等

![](http://i.imgur.com/c2uM5oM.jpg)

对象引用情况查看

有了堆信息查看方面的功能，我们一般可以顺利解决以下问题：

--年老代年轻代大小划分是否合理

--内存泄漏

--垃圾回收算法设置是否合理

**1.1. 线程监控**

![](http://i.imgur.com/ysz4U0n.jpg)

线程信息监控：系统线程数量。

线程状态监控：各个线程都处在什么样的状态下

![](http://i.imgur.com/PWMjKFW.jpg)

Dump线程详细信息：查看线程内部运行情况

死锁检查

**热点分析**

![](http://i.imgur.com/nYKrWvi.jpg)

CPU热点：检查系统哪些方法占用的大量CPU时间

内存热点：检查哪些对象在系统中数量最大（一定时间内存活对象和销毁对象一起统计）

这两个东西对于系统优化很有帮助。我们可以根据找到的热点，有针对性的进行系统的瓶颈查找和进行系统优化，而不是漫无目的的进行所有代码的优化。

**快照**

快照是系统运行到某一时刻的一个定格。在我们进行调优的时候，不可能用眼睛去跟踪所有系统变化，依赖快照功能，我们就可以进行系统两个不同运行时刻，对象（或类、线程等）的不同，以便快速找到问题

举例说，我要检查系统进行垃圾回收以后，是否还有该收回的对象被遗漏下来的了。那么，我可以在进行垃圾回收前后，分别进行一次堆情况的快照，然后对比两次快照的对象情况。

### 十.举例 ###

内存泄漏是比较常见的问题，而且解决方法也比较通用，这里可以重点说一下，而线程、热点方面的问题则是具体问题具体分析了。

内存泄漏一般可以理解为系统资源（各方面的资源，堆、栈、线程等）在错误使用的情况下，导致使用完毕的资源无法回收（或没有回收），从而导致新的资源分配请求无法完成，引起系统错误。

内存泄漏对系统危害比较大，因为他可以直接导致系统的崩溃。

需要区别一下，内存泄漏和系统超负荷两者是有区别的，虽然可能导致的最终结果是一样的。内存泄漏是用完的资源没有回收引起错误，而系统超负荷则是系统确实没有那么多资源可以分配了（其他的资源都在使用）。

**年老代堆空间被占满**

	异常： java.lang.OutOfMemoryError: Java heap space
	
	说明：

![](http://i.imgur.com/xmhcyLO.jpg)

	这是最典型的内存泄漏方式，简单说就是所有堆空间都被无法回收的垃圾对象占满，虚拟机无法再在分配新空间。
	
	如上图所示，这是非常典型的内存泄漏的垃圾回收情况图。所有峰值部分都是一次垃圾回收点，所有谷底部分表示是一次垃圾回收
	后剩余的内存。连接所有谷底的点，可以发现一条由底到高的线，这说明，随时间的推移，系统的堆空间被不断占满，最终会占满整个
	堆空间。因此可以初步认为系统内部可能有内存泄漏。（上面的图仅供示例，在实际情况下收集数据的时间需要更长，比如几个小时或者几天）
	
	解决：
	这种方式解决起来也比较容易，一般就是根据垃圾回收前后情况对比，同时根据对象引用情况（常见的集合对象引用）分析，基本都可以找到泄漏点。

**持久代被占满**

	异常：java.lang.OutOfMemoryError: PermGen space
	
	说明：
	
	Perm空间被占满。无法为新的class分配存储空间而引发的异常。这个异常以前是没有的，
	但是在Java反射大量使用的今天这个异常比较常见了。主要原因就是大量动态反射生成的类不断被加载，最终导致Perm区被占满。
	
	更可怕的是，不同的classLoader即便使用了相同的类，但是都会对其进行加载，相当于同一个东西，
	如果有N个classLoader那么他将会被加载N次。因此，某些情况下，这个问题基本视为无解。当然，存在大量classLoader和大量反射类的情况其实也不多。

	解决：
	1. -XX:MaxPermSize=16m
	2. 换用JDK。比如JRocket。

**堆栈溢出**

	异常：java.lang.StackOverflowError
	说明：这个就不多说了，一般就是递归没返回，或者循环调用造成

**线程堆栈满**

	异常：Fatal: Stack size too small
	说明：java中一个线程的空间大小是有限制的。JDK5.0以后这个值是1M。与这个线程相关的数据将会保存在其中。但是当线程空间满了以后，将会出现上面异常。
	解决：增加线程栈大小。-Xss2m。但这个配置无法解决根本问题，还要看代码部分是否有造成泄漏的部分。

**系统内存被占满**

	异常：java.lang.OutOfMemoryError: unable to create new native thread
	说明：
	　　这个异常是由于操作系统没有足够的资源来产生这个线程造成的。系统创建线程时，除了要在Java堆中分配内存外，
	操作系统本身也需要分配资源来创建线程。因此，当线程数量大到一定程度以后，堆中或许还有空间，但是操作系统分配不出资源来了，就出现这个异常了。
	分配给Java虚拟机的内存愈多，系统剩余的资源就越少，因此，当系统内存固定时，分配给Java虚拟机的内存越多，那么，
	系统总共能够产生的线程也就越少，两者成反比的关系。同时，可以通过修改-Xss来减少分配给单个线程的空间，也可以增加系统总共内生产的线程数。
	
	解决：
	1. 重新设计系统减少线程数量。
	2. 线程数量不能减少的情况下，通过-Xss减小单个线程大小。以便能生产更多的线程。

